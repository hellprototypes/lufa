#include <avr/pgmspace.h>
#include <string.h>
#include "draw.h"
#include "oled.h"
#include "util.h"


//extern const uint8_t smallFont[][5];
// 5x8
const uint8_t smallFont[][5] PROGMEM ={
{0x00,0x00,0x00,0x00,0x00}, // space
{0x00,0x5F,0x00,0x00,0x00}, // !
{0x00,0x07,0x00,0x07,0x00}, // "
{0x14,0x7F,0x14,0x7F,0x14}, // #
{0x24,0x2A,0x7F,0x2A,0x12}, // $
{0x23,0x13,0x08,0x64,0x62}, // %
{0x36,0x49,0x55,0x22,0x50}, // &
{0x00,0x05,0x03,0x00,0x00}, // '
{0x1C,0x22,0x41,0x00,0x00}, // (
{0x41,0x22,0x1C,0x00,0x00}, // )
{0x08,0x2A,0x1C,0x2A,0x08}, // *
{0x08,0x08,0x3E,0x08,0x08}, // +
{0xA0,0x60,0x00,0x00,0x00}, // ,
{0x08,0x08,0x08,0x08,0x08},
{0x60,0x60,0x00,0x00,0x00},
{0x20,0x10,0x08,0x04,0x02},
{0x3E,0x51,0x49,0x45,0x3E},
{0x00,0x42,0x7F,0x40,0x00},
{0x62,0x51,0x49,0x49,0x46},
{0x22,0x41,0x49,0x49,0x36},
{0x18,0x14,0x12,0x7F,0x10},
{0x27,0x45,0x45,0x45,0x39},
{0x3C,0x4A,0x49,0x49,0x30},
{0x01,0x71,0x09,0x05,0x03},
{0x36,0x49,0x49,0x49,0x36},
{0x06,0x49,0x49,0x29,0x1E},
{0x00,0x36,0x36,0x00,0x00},
{0x00,0xAC,0x6C,0x00,0x00},
{0x08,0x14,0x22,0x41,0x00},
{0x14,0x14,0x14,0x14,0x14},
{0x41,0x22,0x14,0x08,0x00},
{0x02,0x01,0x51,0x09,0x06},
{0x32,0x49,0x79,0x41,0x3E},
{0x7E,0x09,0x09,0x09,0x7E},
{0x7F,0x49,0x49,0x49,0x36},
{0x3E,0x41,0x41,0x41,0x22},
{0x7F,0x41,0x41,0x22,0x1C},
{0x7F,0x49,0x49,0x49,0x41},
{0x7F,0x09,0x09,0x09,0x01},
{0x3E,0x41,0x41,0x51,0x72},
{0x7F,0x08,0x08,0x08,0x7F},
{0x41,0x7F,0x41,0x00,0x00},
{0x20,0x40,0x41,0x3F,0x01},
{0x7F,0x08,0x14,0x22,0x41},
{0x7F,0x40,0x40,0x40,0x40},
{0x7F,0x02,0x0C,0x02,0x7F},
{0x7F,0x04,0x08,0x10,0x7F},
{0x3E,0x41,0x41,0x41,0x3E},
{0x7F,0x09,0x09,0x09,0x06},
{0x3E,0x41,0x51,0x21,0x5E},
{0x7F,0x09,0x19,0x29,0x46},
{0x26,0x49,0x49,0x49,0x32},
{0x01,0x01,0x7F,0x01,0x01},
{0x3F,0x40,0x40,0x40,0x3F},
{0x1F,0x20,0x40,0x20,0x1F},
{0x3F,0x40,0x38,0x40,0x3F},
{0x63,0x14,0x08,0x14,0x63},
{0x03,0x04,0x78,0x04,0x03},
{0x61,0x51,0x49,0x45,0x43},
{0x7F,0x41,0x41,0x00,0x00},
{0x02,0x04,0x08,0x10,0x20},
{0x41,0x41,0x7F,0x00,0x00},
{0x04,0x02,0x01,0x02,0x04},
{0x80,0x80,0x80,0x80,0x80},
{0x01,0x02,0x04,0x00,0x00},
{0x20,0x54,0x54,0x54,0x78},
{0x7F,0x48,0x44,0x44,0x38},
{0x38,0x44,0x44,0x28,0x00},
{0x38,0x44,0x44,0x48,0x7F},
{0x38,0x54,0x54,0x54,0x18},
{0x08,0x7E,0x09,0x02,0x00},
{0x18,0xA4,0xA4,0xA4,0x7C},
{0x7F,0x08,0x04,0x04,0x78},
{0x00,0x7D,0x00,0x00,0x00},
{0x80,0x84,0x7D,0x00,0x00},
{0x7F,0x10,0x28,0x44,0x00},
{0x41,0x7F,0x40,0x00,0x00},
{0x7C,0x04,0x18,0x04,0x78},
{0x7C,0x08,0x04,0x7C,0x00},
{0x38,0x44,0x44,0x38,0x00},
{0xFC,0x24,0x24,0x18,0x00},
{0x18,0x24,0x24,0xFC,0x00},
{0x00,0x7C,0x08,0x04,0x00},
{0x48,0x54,0x54,0x24,0x00},
{0x04,0x7F,0x44,0x00,0x00},
{0x3C,0x40,0x40,0x7C,0x00},
{0x1C,0x20,0x40,0x20,0x1C},
{0x3C,0x40,0x30,0x40,0x3C},
{0x44,0x28,0x10,0x28,0x44},
{0x1C,0xA0,0xA0,0x7C,0x00},
{0x44,0x64,0x54,0x4C,0x44},
{0x08,0x36,0x41,0x00,0x00},
{0x00,0x7F,0x00,0x00,0x00}, // {
{0x41,0x36,0x08,0x00,0x00}, // |
{0x02,0x01,0x01,0x02,0x01}, // }
{0x02,0x05,0x05,0x02,0x00} // ~
};

inline static void setBuffByte(uint8_t*, uint8_t, uint8_t, uint8_t);//, uint8_t);

void draw_string(char* string, bool invert, uint8_t x, uint8_t y)
{
	s_image img = newImage(0, y, NULL, SMALLFONT_WIDTH, SMALLFONT_HEIGHT, WHITE, invert, 0);

	uint8_t charCount = 0;
	while(*string)
	{
		char c = *string - 0x20;
		uint8_t xx = x + (charCount*6);
		img.x = xx;
		img.bitmap = smallFont[(uint8_t)c];
		draw_bitmap_s2(&img);
		if(invert)
		{
			if(xx > 0)
				setBuffByte(oledBuffer, xx-1, y, 0xFF);//, WHITE);
			if(xx < FRAME_WIDTH - 5)
				setBuffByte(oledBuffer, xx+5, y, 0xFF);//, WHITE);
		}
		string++;
		charCount++;
	}
}
/*
// Special draw string
// Doesn't draw spaces
// Colons and spaces have smaller width
void draw_string_time(char* string, bool invert, uint8_t x, uint8_t y)
{
	uint8_t charCount = 0;
	while(*string)
	{
		char c = *string;
		if(c != ' ')
		{
			uint8_t b = c;
			c -= 0x30;
			if(b != ':')
				draw_bitmap(x + (charCount), y, midFont[(uint8_t)c], 19, 24, WHITE, invert, 0);
			else
			{
				draw_bitmap(x + (charCount), y, colon, 6, 24, WHITE, invert, 0);
				charCount-=10;
			}
			charCount+=21;
		}
		else
			charCount+=6;
		string++;
	}
}
*/

inline static void setBuffByte(uint8_t* buff, uint8_t x, uint8_t y, uint8_t val)//, uint8_t colour)
{
	uint16_t pos = x + (y / 8) * FRAME_WIDTH;
	buff[pos] |= val;
}

inline static uint8_t readPixels(const uint8_t* loc, bool invert)
{
	uint8_t pixels = pgm_read_byte(loc);
	if(invert)
		pixels = ~pixels;
	return pixels;
}

// Ultra fast bitmap drawing
// Only downside is that height must be a multiple of 8, otherwise it gets rounded down to the nearest multiple of 8
// Drawing bitmaps that are completely on-screen and have a Y co-ordinate that is a multiple of 8 results in best performance
// PS - Sorry about the poorly named variables ;_;
// Optimize: Use a local variable temp buffer then apply to global variable OLED buffer?
void draw_bitmap_s2(s_image* image)
{
	uint8_t x = image->x;
	uint8_t yy = image->y;
	const uint8_t* bitmap = image->bitmap;
	uint8_t w = image->width;
	uint8_t h = image->height;
//	uint8_t colour = image->foreColour;
	bool invert = image->invert;
	uint8_t offsetY = image->offsetY;

	// 
	uint8_t y = yy - offsetY;

	// 
	uint8_t h2 = h / 8;
	
	// 
	uint8_t pixelOffset = (y % 8);

	uint8_t thing3 = (yy+h);

	// 
	for(uint8_t hh=0;hh<h2;hh++)
	{
		// 
		uint8_t hhh = (hh*8) + y;
		uint8_t hhhh = hhh + 8;

		// 
		if(offsetY && (hhhh < yy || hhhh > FRAME_HEIGHT || hhh > thing3))
			continue;

		// 
		uint8_t offsetMask = 0xFF;
		if(offsetY)
		{
			if(hhh < yy)
				offsetMask = (0xFF<<(yy-hhh));
			else if(hhhh > thing3)
				offsetMask = (0xFF>>(hhhh-thing3));
		}

		uint16_t aa = ((hhh / 8) * FRAME_WIDTH);

		// If() outside of loop makes it faster (doesn't have to kee re-evaluating it)
		// Downside is code duplication
		if(!pixelOffset && hhh < FRAME_HEIGHT)
		{
			// 
			for(uint8_t ww=0;ww<w;ww++)
			{
				// Workout X co-ordinate in frame buffer to place next 8 pixels
				uint8_t xx = ww + x;

				// Stop if X co-ordinate is outside the frame
				if(xx >= FRAME_WIDTH)
					continue;

				// Read pixels
				uint8_t pixels = readPixels((bitmap + (hh*w)) + ww, invert) & offsetMask;

				oledBuffer[xx + aa] |= pixels;

				//setBuffByte(buff, xx, hhh, pixels, colour);
			}
		}
		else
		{
			uint16_t aaa = ((hhhh / 8) * FRAME_WIDTH);
			
			// 
			for(uint8_t ww=0;ww<w;ww++)
			{
				// Workout X co-ordinate in frame buffer to place next 8 pixels
				uint8_t xx = ww + x;

				// Stop if X co-ordinate is outside the frame
				if(xx >= FRAME_WIDTH)
					continue;

				// Read pixels
				uint8_t pixels = readPixels((bitmap + (hh*w)) + ww, invert) & offsetMask;

				// 
				if(hhh < FRAME_HEIGHT)
					oledBuffer[xx + aa] |= pixels << pixelOffset;
					//setBuffByte(buff, xx, hhh, pixels << pixelOffset, colour);				

				// 
				if(hhhh < FRAME_HEIGHT)
					oledBuffer[xx + aaa] |= pixels >> (8 - pixelOffset);
					//setBuffByte(buff, xx, hhhh, pixels >> (8 - pixelOffset), colour);			
			}
		}		
	}
}

// y must be a multiple of 8
// height is always 8
void draw_clearArea(uint8_t x, uint8_t y, uint8_t w)
{
	uint16_t pos = x + (y / 8) * FRAME_WIDTH;
	memset(&oledBuffer[pos], 0x00, w);
}

void draw_end()
{
	oled_flush();
}


